<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Steal a Brainrot — Single Player</title>
<style>
  body {margin:0;background:#0b0f1a;color:#eee;font-family:sans-serif;display:flex;flex-direction:column;align-items:center;gap:10px;padding:10px}
  canvas {background:#11182a;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.5)}
  .hud {display:flex;gap:20px;background:#1a2238;padding:6px 12px;border-radius:8px}
  .hud span {font-weight:bold;color:#ffd659}
  .footer {font-size:13px;color:#aaa;text-align:center;max-width:800px}
</style>
</head>
<body>
<div class="hud">
  <div>Score: <span id="score">0</span></div>
  <div>Time: <span id="time">00:00</span></div>
  <div>Status: <span id="status">Find the Brainrot</span></div>
</div>
<canvas id="game" width="800" height="600" tabindex="0"></canvas>
<div class="footer">
  WASD / Arrow keys to move • Hold <b>Shift</b> to dash • Grab the yellow Brainrot and bring it back to the green base • Avoid red guards!
</div>
<script>
const canvas=document.getElementById("game"),ctx=canvas.getContext("2d");
const W=canvas.width,H=canvas.height;
const hud={score:document.getElementById("score"),time:document.getElementById("time"),status:document.getElementById("status")};

// --- Player
let player={x:80,y:500,r:14,speed:2,dashSpeed:5,dashTime:0,dashCd:0,carrying:false};

// --- Brainrot (the thing to steal)
let brain={x:700,y:520,r:12,carried:false};

// --- Base
let base={x:60,y:60,r:26};

// --- Guards
function makeGuard(x,y,path){return{x,y,r:16,path,index:0,speed:1.3,state:"patrol"};}
let guards=[
  makeGuard(600,160,[{x:600,y:160},{x:720,y:260},{x:640,y:360}]),
  makeGuard(420,360,[{x:420,y:360},{x:520,y:440},{x:620,y:360}])
];

// Obstacles (walls)
const obstacles=[{x:200,y:120,w:120,h:28},{x:400,y:80,w:260,h:28},{x:320,y:260,w:40,h:160},{x:120,y:400,w:180,h:28},{x:520,y:400,w:200,h:28}];

// Input
let keys={};
window.addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
window.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

// Utils
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

// Collision with walls
function resolveCollide(obj,r){
  for(let o of obstacles){
    let nx=clamp(obj.x,o.x,o.x+o.w),ny=clamp(obj.y,o.y,o.y+o.h);
    let dx=obj.x-nx,dy=obj.y-ny,d2=dx*dx+dy*dy;
    if(d2<r*r){
      let d=Math.sqrt(d2)||0.001;
      obj.x+=dx/d*(r-d);obj.y+=dy/d*(r-d);
    }
  }
  obj.x=clamp(obj.x,r,W-r);obj.y=clamp(obj.y,r,H-r);
}

// Game state
let score=0,start=Date.now();

// Update
function update(dt){
  // Time HUD
  let t=Math.floor((Date.now()-start)/1000);
  hud.time.textContent=("0"+Math.floor(t/60)).slice(-2)+":"+("0"+t%60).slice(-2);

  // Player movement
  let ix=0,iy=0;
  if(keys["w"]||keys["arrowup"])iy-=1;
  if(keys["s"]||keys["arrowdown"])iy+=1;
  if(keys["a"]||keys["arrowleft"])ix-=1;
  if(keys["d"]||keys["arrowright"])ix+=1;
  let len=Math.hypot(ix,iy);if(len>0){ix/=len;iy/=len;}
  if(keys["shift"]&&player.dashCd<=0&&len>0){player.dashTime=0.18;player.dashCd=1.2;}
  if(player.dashTime>0){player.dashTime-=dt;sp=player.dashSpeed;}else{sp=player.speed;}
  if(player.dashCd>0)player.dashCd-=dt;
  player.x+=ix*sp;player.y+=iy*sp;
  resolveCollide(player,player.r);

  // Brain pickup
  if(!brain.carried && dist(player,brain)<player.r+brain.r+4){
    brain.carried=true;player.carrying=true;hud.status.textContent="Carrying Brainrot!";
  }
  if(brain.carried){brain.x=player.x+Math.cos(Date.now()/200)*2;brain.y=player.y+Math.sin(Date.now()/200)*2;}

  // Drop at base
  if(player.carrying && dist(player,base)<player.r+base.r){
    score++;hud.score.textContent=score;
    player.carrying=false;brain.carried=false;
    brain.x=100+Math.random()*(W-200);brain.y=100+Math.random()*(H-200);
    hud.status.textContent="Find the Brainrot";
  }

  // Guards
  for(let g of guards){
    let target=g.path[g.index];
    let dx=target.x-g.x,dy=target.y-g.y,d=Math.hypot(dx,dy);
    if(d<4){g.index=(g.index+1)%g.path.length;}
    else{g.x+=dx/d*g.speed;g.y+=dy/d*g.speed;}
    // detect player
    if(dist(g,player)<50){
      // reset game
      score=0;hud.score.textContent=score;
      player.x=80;player.y=500;player.carrying=false;brain.carried=false;
      brain.x=700;brain.y=520;hud.status.textContent="Caught! Restarted.";
    }
  }
}

// Draw
function draw(){
  ctx.clearRect(0,0,W,H);
  // Base
  ctx.fillStyle="#2ecc71";ctx.beginPath();ctx.arc(base.x,base.y,base.r,0,Math.PI*2);ctx.fill();
  // Obstacles
  ctx.fillStyle="#1a2238";for(let o of obstacles){ctx.fillRect(o.x,o.y,o.w,o.h);}
  // Brain
  ctx.fillStyle="#ffd659";ctx.beginPath();ctx.arc(brain.x,brain.y,brain.r,0,Math.PI*2);ctx.fill();
  // Player
  ctx.fillStyle="#4da6ff";ctx.beginPath();ctx.arc(player.x,player.y,player.r,0,Math.PI*2);ctx.fill();
  // Guards
  ctx.fillStyle="#ff4d4d";for(let g of guards){ctx.beginPath();ctx.arc(g.x,g.y,g.r,0,Math.PI*2);ctx.fill();}
}

// Loop
let last=performance.now();
function loop(ts){let dt=(ts-last)/1000;last=ts;update(dt);draw();requestAnimationFrame(loop);}
requestAnimationFrame(loop);
</script>
</body>
</html>
